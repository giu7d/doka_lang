options {
  STATIC = true;
}

PARSER_BEGIN(Doka)

import javax.swing.*;
import java.io.*;

public class Doka {

    private static Boolean displayTree = false;

    public static void main(String args[]) throws ParseException {

        System.out.println("------------------------");
        System.out.println("\") Doka Language ");
        System.out.println("\tv0.0.1");
        System.out.println("------------------------\n");

        if (args.length == 0) {
            System.out.println(
                "doka <params>\n\n" +
                "Examples:\n" +
                "\tdoka ./example.dk\tUse path to load file\n" +
                "\tdoka -i\t\t\tUse GUI to load file\n" +
                "\tdoka -c\t\t\tUse interpreter mode\n" +
                "\tdoka -t <params>\tDisplay parse tree\n" +
                "\tdoka -t ./example.dk\tDisplay parse tree in file mode\n" +
                "\tdoka -t -c\t\tDisplay parse tree in interpreter mode\n" +
                "\tdoka -t -i\t\tDisplay parse tree in GUI mode\n"
            );
            return;
        }

        try {
            for (String arg : args) {
                if (arg.equals("-t")) {
                    System.out.println(">\tUsing display parse tree [-t]");
                    displayTree = true;
                } else if (arg.equals("-c")) {
                    System.out.println(">\tUsing CLI interpreter [-c]");
                    parseInputStream();
                } else if (arg.equals("-i")) {
                    System.out.println(">\tUsing interface [-i]");
                    String path = Doka.getFilePathFromUI();
                    parseFileStream(path);
                } else if (arg.matches("(.*).dk")) {
                    System.out.printf(">\tUsing File [%s]\n", arg);
                    File file = new File(arg);
                    parseFileStream(file.getAbsolutePath());
                } else {
                    System.out.println(
                        "doka <params>\n\n" +
                        "Examples:\n" +
                        "\tdoka ./example.dk\tUse path to load file\n" +
                        "\tdoka -i\t\t\tUse GUI to load file\n" +
                        "\tdoka -c\t\t\tUse interpreter mode\n" +
                        "\tdoka -t <params>\tDisplay parse tree\n"
                    );
                }
            }
        } catch (Exception e) {
            System.out.println(":Error");
            System.out.println(e.getMessage());
        }
    }

    public static void parseFileStream(String path) {
        try {
            System.out.println(">\tParsing...");
            BufferedReader fileBuffer = Doka.getFileBuffer(path);
            Doka parser = new Doka(fileBuffer);
            SimpleNode tree = parser.Main();
            showTree(tree);
        } catch (ParseException e) {
            System.out.println(":Error:Parser");
            System.out.println(e.getMessage());
        } catch (Exception e) {
            System.out.println(":Error");
            System.out.println(e.getMessage());
        }
    }

    public static void parseInputStream() {
        Doka parser = new Doka(System.in);
        System.out.println(">\tListen for input...\n");

        while (true) {
            try{
                SimpleNode tree = parser.Main();
                showTree(tree);
            } catch (Exception e) {
                System.out.println(":Error");
                System.out.println(e.getMessage());
                Doka.ReInit(System.in);
            }
        }
    }

    public static void showTree(SimpleNode tree) {
        if (displayTree) {
            System.out.println(">\tParse tree");
            tree.dump("\t|\t");
        }
    }

    public static BufferedReader getFileBuffer(String path){
        BufferedReader buffer;

        try {

            System.out.println(">\tReading File");
            File file  = new File(path);
            FileReader reader = new FileReader(file);
            buffer = new BufferedReader(reader);
        } catch (IOException e) {
            buffer = null;
            System.out.println(":Error:IO:getFileBuffer");
            System.out.println(e.getMessage());
        }

        return buffer;
    }

    public static String getFilePathFromUI() {
        JFileChooser chooseFile = new JFileChooser();
        chooseFile.showOpenDialog(null);
        String path = chooseFile.getSelectedFile().getAbsolutePath();
        System.out.println(">\tLoad file: " + path);
        return path;
    }

}

PARSER_END(Doka)

SKIP : {
    " "  | "\t"
}

// Reserved Words
TOKEN : {
    <MODULE: "module">
|   <EXIT: "exit">
|   <FUNCTION: "fun">
|   <IF: "if">
|   <ELSE: "else">
|   <ELSEIF: "else if">
}

// Operators
TOKEN : {
    <AND: "&&">
|   <OR: "||" >
| 	<SUM: "+">
|	<SUBTRACT: "-">
|	<MULTIPLY: "*">
|	<DIVIDE: "/">
|	<REST: "%">
|	<ASSIGN_VALUE: "=">
| 	<ASSIGN_OPERATION: "->">
|	<GREATER: ">" >
|	<SMALLER: "<">
|	<GREATER_OR_EQUAL: "<=" >
|	<SMALLER_OR_EQUAL: ">=" >
|	<DIFFERENT: "!=">
|	<EQUAL: "==">
|	<PIPE: "|>">
}

// Symbols
TOKEN : {
    <UNDERLINE: "_">
|   <DOT: ".">
|   <COMMA: ",">
|   <EOL: "\n" | "\r" | "\r\n" >
|   <ARROW: "=>">
| 	<QUOTE: "\"">
|   <START_BRACKET: "[">
|   <END_BRACKET: "]">
|   <START_PARAM: "(">
|   <END_PARAM: ")">
|   <START_BLOCK: ":">
|   <END_BLOCK: "end">
|   <#DIGIT: ["0"-"9"]>
|   <#UPPER_CASE_CHAR: ["A"-"Z"]>
|   <#LOWER_CASE_CHAR: ["a"-"z"]>
|   <#ID_CHAR: (<LOWER_CASE_CHAR> | <UPPER_CASE_CHAR> | <UNDERLINE> )>
}

// IDs
TOKEN : {
    <MODULE_ID: (<UPPER_CASE_CHAR>(<UPPER_CASE_CHAR> | <LOWER_CASE_CHAR> | <DIGIT>)*)>
|   <GENERIC_ID: (<ID_CHAR> (<ID_CHAR> | <DIGIT>)* | (<DOT> (<ID_CHAR> | <DIGIT>)+)+)>
}

// Types
TOKEN : {
	 <NUMBER: (<DIGIT>)+( "." (<DIGIT>)+)?>
|    <STRING: (<QUOTE> (~["\""])* <QUOTE>)>
|    <BOOLEAN: ("true" | "false")>
}


SimpleNode Main() :
{}
{
    (<EOF>|<EXIT><EOL>) {
        return jjtThis;
    }
|    <MODULE> <MODULE_ID> <EOL>
        (define_module_block() | <EOL>)*
    (<EOF>|<EXIT><EOL>) {
        return jjtThis;
    }
}

// Blocks
void define_module_block():
{}
{
    declare_function()
|   declare_condition()
|   <GENERIC_ID> (assign_constant() | assign_operation() | call_function())?
}

void define_function_block():
{}
{
    <GENERIC_ID > ( assign_constant() | assign_operation())
|   declare_condition()
|   <PIPE> define_function_block()
}

// Declarative Structures
void declare_function():
{}
{
    <FUNCTION> <GENERIC_ID> define_function_params() <START_BLOCK> (<EOL>)*
        (define_function_block() (<EOL>)*)+
    <END_BLOCK> <EOL>
}

void declare_condition():
{}
{
  <IF> define_conditional_params() <START_BLOCK> (<EOL>)*
    (define_function_block() (<EOL>)*)+
  (<ELSEIF> define_conditional_params() <START_BLOCK> (<EOL>)*
    (define_function_block() (<EOL>)*)+
  )*
  (<ELSE> <START_BLOCK> (<EOL>)*
    (define_function_block() (<EOL>)*)+
  )?
  <END_BLOCK> <EOL>
}

void assign_constant () :
{}
{
    <ASSIGN_VALUE> expression() <EOL>
}

void assign_operation () :
{}
{
    <ASSIGN_OPERATION> relational_expression() <EOL>
}

void call_function () :
{}
{
    (define_function_params())+
}

// Expressions
void expression():
{}
{
    declarative_expression()
|   callable_expression()
}

void callable_expression():
{}
{
    <GENERIC_ID> (call_function())?
}

void declarative_expression():
{}
{
    declare_types()
|   declare_list()
|   declare_lambda_function()
}

void relational_expression():
{}
{
   define_expression_priority()
|  expression()(logical_expression() | mathematical_expression())
}

void logical_expression():
{}
{
  logic_operator() (expression() | define_expression_priority())+
}

void mathematical_expression():
{}
{
  math_operator()(expression() | define_expression_priority())+
}


// Definitions
void define_expression_priority():
{}
{
  <START_PARAM> relational_expression() <END_PARAM>(logical_expression() | mathematical_expression())?
}

void define_expression_list():
{}
{
    expression() (<COMMA> expression())*
}

void define_function_params():
{}
{
   <START_PARAM> (define_expression_list())* <END_PARAM>
}

void define_conditional_params():
{}
{
   <START_PARAM> relational_expression()(logic_operator()relational_expression())*  <END_PARAM>
}

// Declarations
void declare_list():
{}
{
   <START_BRACKET> (define_expression_list())* <END_BRACKET>
}

void declare_lambda_function():
{}
{
     <START_BLOCK> define_function_params() <ARROW> (<EOL>)*
        (define_function_block() (<EOL>)*)+
     <END_BLOCK>
}

void declare_types():
{}
{
    <NUMBER>
|   <STRING>
|   <BOOLEAN>
}

// Operators
void math_operator():
{}
{
    <SUM>
|   <SUBTRACT>
|   <MULTIPLY>
|   <DIVIDE>
|   <REST>
}

void logic_operator():
{}
{
	<AND>
|	<OR>
|   <GREATER>
|	<SMALLER>
|	<GREATER_OR_EQUAL>
|	<SMALLER_OR_EQUAL>
|	<DIFFERENT>
|	<EQUAL>
}









