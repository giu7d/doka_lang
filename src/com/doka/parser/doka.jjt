options {
  STATIC = true;
  OUTPUT_DIRECTORY = "parser";
  GRAMMAR_ENCODING = "ISO_8859-1";
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(Doka)
package parser;
import javax.swing.*;
import java.io.*;
import recovery.*;

public class Doka {

    private static Boolean displayTree = false;

    public static void main(String args[]) throws ParseException {

        System.out.println("------------------------");
        System.out.println("\") Doka Language ");
        System.out.println("\tv0.0.1");
        System.out.println("------------------------\n");

        if (args.length == 0) {
            System.out.println(
                "doka <params>\n\n" +
                "Examples:\n" +
                "\tdoka ./example.dk\tUse path to load file\n" +
                "\tdoka -i\t\t\tUse GUI to load file\n" +
                "\tdoka -c\t\t\tUse interpreter mode\n" +
                "\tdoka -t <params>\tDisplay parse tree\n" +
                "\tdoka -t ./example.dk\tDisplay parse tree in file mode\n" +
                "\tdoka -t -c\t\tDisplay parse tree in interpreter mode\n" +
                "\tdoka -t -i\t\tDisplay parse tree in GUI mode\n"
            );
            return;
        }

        try {
            for (String arg : args) {
                if (arg.equals("-t")) {
                    System.out.println(">\tUsing display parse tree [-t]");
                    displayTree = true;
                } else if (arg.equals("-c")) {
                    System.out.println(">\tUsing CLI interpreter [-c]");
                    parseInputStream();
                } else if (arg.equals("-i")) {
                    System.out.println(">\tUsing interface [-i]");
                    String path = Doka.getFilePathFromUI();
                    parseFileStream(path);
                } else if (arg.matches("(.*).dk")) {
                    System.out.printf(">\tUsing File [%s]\n", arg);
                    File file = new File(arg);
                    parseFileStream(file.getAbsolutePath());
                } else {
                    System.out.println(
                        "doka <params>\n\n" +
                        "Examples:\n" +
                        "\tdoka ./example.dk\tUse path to load file\n" +
                        "\tdoka -i\t\t\tUse GUI to load file\n" +
                        "\tdoka -c\t\t\tUse interpreter mode\n" +
                        "\tdoka -t <params>\tDisplay parse tree\n"
                    );
                }
            }
        } catch (Exception e) {
            System.out.println(":Error");
            System.out.println(e.getMessage());
        }
    }

      public static String im(int x)
      {
        int k;
    	String s;
        s = tokenImage[x];
        k = s.lastIndexOf("\"");
        try {
          s = s.substring(1,k);
        }
       catch (StringIndexOutOfBoundsException e)
    	   {}
       return s;
      }

      static Token lastError = null;
      static boolean eof;

      static void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException{
    	Token tok;
    	System.out.println();
    	System.out.println("*** " + met + " ***");
    	System.out.println("     Conjunto de sincronização: " + g);

    	if (g == null) throw e;

    	tok = getToken(1);
    	while ( ! eof )	{
    	  if ( g.contains(tok.kind)) {
    	    System.out.println("     Encontrado token de sincronização: " +
    	                       im(tok.kind));
    	    break;
    	  }
    	  System.out.println("     Ignorando o token: " + im(tok.kind));
    	  getNextToken();
          tok = getToken(1);
    	  if (tok.kind == EOF && ! g.contains(EOF) )
    	      eof = true;
    	}
        if ( tok != lastError)  {
    	  System.out.println(e.getMessage());
    	  lastError = tok;

    	}
    	if ( eof )
    	  throw new ParseEOFException("Encontrei EOF onde não deveria.");
      }

    public static void parseFileStream(String path) {
          BufferedReader fileBuffer;
          fileBuffer = Doka.getFileBuffer(path);
          try {
            System.out.println(">\tParsing...");

            Doka parser = new Doka(fileBuffer);
            SimpleNode tree = parser.Main();
            showTree(tree);
        } catch (Exception e) {
            System.out.println(">\tException");
            System.out.println(e.getMessage());
            Doka.ReInit(fileBuffer);
        } catch (Error e){
            System.out.println(">\tError");
            System.out.println(e.getMessage());
        }
    }

    public static void parseInputStream() {
        Doka parser = new Doka(System.in);
        System.out.println(">\tListen for input...\n");

        while (true) {
            try{
                SimpleNode tree = parser.Main();
                showTree(tree);
            } catch (Exception e) {
                System.out.println(":Exception");
                System.out.println(e.getMessage());
                Doka.ReInit(System.in);
            }  catch (Error e){
                  System.out.println(">\tError");
                  System.out.println(e.getMessage());
              }
        }
    }

    public static void showTree(SimpleNode tree) {
        if (displayTree) {
            System.out.println(">\tParse tree");
            tree.dump("\t|\t");
        }
    }

    public static BufferedReader getFileBuffer(String path){
        BufferedReader buffer;

        try {
            System.out.println(">\tReading File");
            File file  = new File(path);
            FileReader reader = new FileReader(file);
            buffer = new BufferedReader(reader);
        } catch (IOException e) {
            buffer = null;
            System.out.println(":Error:IO:getFileBuffer");
            System.out.println(e.getMessage());
        }

        return buffer;
    }

    public static String getFilePathFromUI() {
        JFileChooser chooseFile = new JFileChooser();
        chooseFile.showOpenDialog(null);
        String path = chooseFile.getSelectedFile().getAbsolutePath();
        System.out.println(">\tLoad file: " + path);
        return path;
    }
}

PARSER_END(Doka)

SKIP : {
    " "  | "\t"
}

// Reserved Words
TOKEN : {
    <MODULE: "module">
|   <EXIT: "exit">
|   <FUNCTION: "fun">
|   <IF: "if">
|   <ELSE: "else">
|   <ELSEIF: "else if">
}

// Modules
TOKEN : {
    <IO_MODULE: "IO">
|   <LIST_MODULE: "List">
}

// Operators
TOKEN : {
    <AND: "&&">
|   <OR: "||" >
| 	<SUM: "+">
|	<SUBTRACT: "-">
|	<MULTIPLY: "*">
|	<DIVIDE: "/">
|	<REST: "%">
|	<ASSIGN: "=">
|	<GREATER: ">" >
|	<SMALLER: "<">
|	<GREATER_OR_EQUAL: "<=" >
|	<SMALLER_OR_EQUAL: ">=" >
|	<DIFFERENT: "!=">
|	<EQUAL: "==">
|	<PIPE: "|>">
}

// Symbols
TOKEN : {
    <UNDERLINE: "_">
|   <DOT: ".">
|   <COMMA: ",">
|   <EOL: "\n" | "\r" | "\r\n" >
|   <ARROW: "->">
|   <RETURN_ARROW: "<-">
| 	<QUOTE: "\"">
|   <START_BRACKET: "[">
|   <END_BRACKET: "]">
|   <START_PARAM: "(">
|   <END_PARAM: ")">
|   <START_BLOCK: ":">
|   <END_BLOCK: "end">
|   <#DIGIT: ["0"-"9"]>
|   <#UPPER_CASE_CHAR: ["A"-"Z"]>
|   <#LOWER_CASE_CHAR: ["a"-"z"]>
|   <#ID_CHAR: (<LOWER_CASE_CHAR> | <UPPER_CASE_CHAR> | <UNDERLINE> )>
}

// IDs
TOKEN : {
    <MODULE_ID: (<UPPER_CASE_CHAR>(<UPPER_CASE_CHAR> | <LOWER_CASE_CHAR> | <DIGIT>)*)>
|   <GENERIC_ID: (<ID_CHAR> (<ID_CHAR> | <DIGIT>)*)>
}

// Types
TOKEN : {
	 <NUMBER: (<DIGIT>)+( "." (<DIGIT>)+)?>
|    <STRING: (<QUOTE> (~["\""])* <QUOTE>)>
|    <BOOLEAN: ("true" | "false")>
}


SimpleNode Main() throws ParseEOFException:
{RecoverySet sync = Follow.Main;}
{
    try{
        (<EOL>)* (<EOF>|<EXIT><EOL>) { return jjtThis; }
        | <MODULE> <MODULE_ID> <EOL>
            (block() | <EOL>)*
          (<EOF>|<EXIT><EOL>) { return jjtThis; }
    }catch(ParseException e){
        consumeUntil(sync, e, "main");
    }
}

// Blocks

void block() throws ParseEOFException:
{RecoverySet sync = Follow.block;}
{
    try{
        declaration_statements()
    |   module_statements()
    }catch(ParseException e){
         consumeUntil(sync, e, "bloco");
    }
}

// Statements
void declaration_statements() throws ParseEOFException:
{RecoverySet sync = Follow.declaration_statements;}
{
    try{
            id() (declare_assignment() | (declare_function_params())+)
        |   declare_function() | declare_condition()
    }catch(ParseException e){
         consumeUntil(sync, e, "declaração");
    }
}

void module_statements() throws ParseEOFException:
{RecoverySet sync = Follow.module_statements;}
{
    try{
        <LIST_MODULE><DOT>id()declare_function_params()
        | <IO_MODULE><DOT>id()module_io_params()
    }catch(ParseException e){
         consumeUntil(sync, e, "declaração de módulo");
    }
}

void common_expressions() throws ParseEOFException:
{RecoverySet sync = Follow.common_expressions;}
{
    try{
        (id() (callable_expression())* ( numerical_expression()  | logical_expression())*)
            | ((number() | priority_expression()) (numerical_expression()  | logical_expression())*)
            | ((bool() | string() ) (logical_expression())*)
    }catch(ParseException e){
        consumeUntil(sync, e, "expressão comum");
    }
}

void module_io_params() throws ParseEOFException:
{RecoverySet sync = Follow.module_io_params;}
{
    try{
            <START_PARAM>
                common_expressions() (<COMMA>common_expressions() )*
            <END_PARAM>
    }catch(ParseException e){
        consumeUntil(sync, e, "parametros de modulo IO");
    }
}

// Declarations

void declare_assignment() throws ParseEOFException:
{RecoverySet sync = Follow.declare_assignment;}
{
    try{
        <ASSIGN>(common_expressions()| expression())
    }catch(ParseException e){
        consumeUntil(sync, e, "atribuição");
    }
}

void id() throws ParseEOFException:
{RecoverySet sync = Follow.id;}
{
    try{
        <GENERIC_ID>
    }catch(ParseException e){
        consumeUntil(sync, e, "identificador");
    }

}

void functional_block() throws ParseEOFException:
{RecoverySet sync = Follow.functional_block;}
{
    try{
        (block()(<EOL>)*)* (<RETURN_ARROW> return_expression()(<EOL> | return_expression())*)?
    }catch(ParseException e){
        consumeUntil(sync, e, "bloco de função");
    }
}

void declare_condition() throws ParseEOFException:
{RecoverySet sync = Follow.declare_condition;}
{
    try{
          <IF> declare_conditional_params() <START_BLOCK> (<EOL>)*
            functional_block()
          (<ELSEIF> declare_conditional_params() <START_BLOCK> (<EOL>)*
            functional_block()
          )*
          (<ELSE> <START_BLOCK> (<EOL>)*
            functional_block()
          )?
          <END_BLOCK><EOL>
    }catch(ParseException e){
        consumeUntil(sync, e, "declaração de condição");
    }

}

void declare_lambda_function() throws ParseEOFException:
{RecoverySet sync = Follow.declare_lambda_function;}
{
    try{
        <START_BLOCK> declare_function_params() <ARROW>(<EOL>)*
            return_expression()(<EOL>)*
        <END_BLOCK>
    }catch(ParseException e){
        consumeUntil(sync, e, "declaração de função lambda");
    }
}

void declare_function() throws ParseEOFException:
{RecoverySet sync = Follow.declare_function;}
{
    try{
            <FUNCTION> id() declare_function_params() <START_BLOCK> (<EOL>)+
                functional_block()
            <END_BLOCK>
    }catch(ParseException e){
        consumeUntil(sync, e, "declaração de função");
    }

}

void declare_list() throws ParseEOFException:
{RecoverySet sync = Follow.declare_list;}
{
    try{
       <START_BRACKET> (list_expression() (<COMMA> list_expression())*)? <END_BRACKET>
    }catch(ParseException e){
        consumeUntil(sync, e, "declaração de lista");
    }
}

void declare_conditional_params() throws ParseEOFException:
{RecoverySet sync = Follow.declare_conditional_params;}
{
    try{
         <START_PARAM>common_expressions()<END_PARAM>
    }catch(ParseException e){
         consumeUntil(sync, e, "declaração de parâmetro condicional");
    }

}

void declare_function_params() throws ParseEOFException:
{RecoverySet sync = Follow.declare_conditional_params;}
{
    try{
           <START_PARAM>
                (list_expression()(<COMMA> list_expression())*)?
           <END_PARAM>
    }catch(ParseException e){
        consumeUntil(sync, e, "declaração de parâmetro de função");
    }
}

// Expressions

void return_expression() throws ParseEOFException:
{RecoverySet sync = Follow.return_expression;}
{
    try{
            ((id()(declare_function_params())? ) | number() )(numerical_expression()  | logical_expression())*
            |  (bool() | string()) (logical_expression())*
            | expression()
            | <PIPE> return_expression()
    }catch(ParseException e){
        consumeUntil(sync, e, "expressão de retorno");
    }
}

void string()
    throws ParseEOFException:{
        RecoverySet sync = Follow.string;
 }
 {
    try{
            <STRING>
    }catch(ParseException e){
        consumeUntil(sync, e, "tipo string");
    }
}

void bool() throws ParseEOFException:
{RecoverySet sync = Follow.bool;}{
    try{
            <BOOLEAN>
    }catch(ParseException e){
        consumeUntil(sync, e, "tipo boolean");
    }
}

void number() throws ParseEOFException:
{RecoverySet sync = Follow.number;}
{
    try{
          <NUMBER>
    }catch(ParseException e){
        consumeUntil(sync, e, "tipo number");
    }
}

void expression() throws ParseEOFException:
{RecoverySet sync = Follow.expression;}
{
    try{
            declare_lambda_function()
        |   declare_list()
        |   module_statements()
    }catch(ParseException e){
        consumeUntil(sync, e, "Expressão");
    }

}

void logical_expression() throws ParseEOFException:
{RecoverySet sync = Follow.logical_expression;}
{
    try{
            logic_operator()  (number() | priority_expression() | bool() | string() | id() )

    }catch(ParseException e){
        consumeUntil(sync, e, "expressão lógica ");
    }

}

void numerical_expression() throws ParseEOFException:
{RecoverySet sync = Follow.numerical_expression;}
{
    try{
           math_operator() (number() | priority_expression() | id())
    }catch(ParseException e){
        consumeUntil(sync, e, "expressão numérica");
    }
}

void callable_expression() throws ParseEOFException:
{RecoverySet sync = Follow.callable_expression;}
{
    try{
           brackets_expression()
       |   declare_function_params()
    }catch(ParseException e){
        consumeUntil(sync, e, "expressão de chamada");
    }
}

void priority_expression() throws ParseEOFException:
{RecoverySet sync = Follow.priority_expression;}
{
    try{
        <START_PARAM>
          ( id() (callable_expression())? | number() ) ( numerical_expression()  | logical_expression())*
        <END_PARAM>
    }catch(ParseException e){
        consumeUntil(sync, e, "Expressão prioridade");
    }
}

void list_expression() throws ParseEOFException:
{RecoverySet sync = Follow.list_expression;}
{
    try{
        ( id() (callable_expression())* | number() ) (numerical_expression())* | bool() | string()  | expression()
    }catch(ParseException e){
        consumeUntil(sync, e, "Expressão de lista");
    }

}

void brackets_expression() throws ParseEOFException:
{RecoverySet sync = Follow.brackets_expression;}
{
    try{
       <START_BRACKET>
            number()
       <END_BRACKET>
    }catch(ParseException e){
        consumeUntil(sync, e, "Expressão de colchetes");
    }
}

void math_operator() throws ParseEOFException:
{RecoverySet sync = Follow.math_operator;}
{
    try{
        <SUM> | <SUBTRACT> | <MULTIPLY> | <DIVIDE> | <REST>
    }catch(ParseException e){
        consumeUntil(sync, e, "operador matemático");
    }
}

void logic_operator() throws ParseEOFException:
{RecoverySet sync = Follow.logic_operator;}
{
    try{
        <AND> |	<OR> | <GREATER>| <SMALLER> | <GREATER_OR_EQUAL> | <SMALLER_OR_EQUAL> |	<DIFFERENT> | <EQUAL>
    }catch(ParseException e){
        consumeUntil(sync, e, "operador lógico");
    }
}
